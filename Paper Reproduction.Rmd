---
title: "29th July"
output: pdf_document
date: "2022-07-29"
---

```{r setting echo=FALSE,message = FALSE,warning = FALSE}
knitr::opts_chunk$set(echo = FALSE,message = FALSE,warning = FALSE,fig.align='center',out.width='100%')
library(tidyverse)
library(dplyr)
library(nnet) # Multinomial logistic
library(kableExtra)
library(latex2exp)
library(MASS) #stepAIC
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(splines)
library(glmnet) # shrinkage
library(grid)
library(caret)#upsample & train models
library(ROCR)# ROC 
library(magrittr) # for pipes
library(MNLpred)
library(scales)
library(ggiraphExtra)
library(patchwork)
library(effects)
library(ggeffects) #ggpredict
library(reshape2)#melt for ggplot
Entitycolors<-c("#FF0C0C", "#C66A2E", "#FFFE5A", "#5FF742", "#016BE9","#8519CD") #colors

#Hosmer-Lemeshow tests in the appendix
#library(ResourceSelection)

# AUC
library(multiROC) #for individual AUC and macro-micro AUC
library(pROC) #for multiclass AUC 

```

# Loading Data

```{r Loading}
#start here: loading data
load("dataAugust2022.RData")
```

# Table 1

```{r Table1}
# Table 1 of the paper: Second-order transition counts and empirical transition probabilities
Order2Transit <- matrix(c(
                      nrow(filter(data0612_Order2, order2comb==1 & stateto==1 & Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==1 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==1 & stateto==3& Year !=2013)),
                      nrow(filter(data0612_Order2, order2comb==2 & stateto==1& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==2 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==2 & stateto==3& Year !=2013)),
                      nrow(filter(data0612_Order2, order2comb==3 & stateto==1 & Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==3 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==3 & stateto==3& Year !=2013)),
                      nrow(filter(data0612_Order2, order2comb==4 & stateto==1& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==4 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==4 & stateto==3& Year !=2013)),
                      nrow(filter(data0612_Order2, order2comb==5 & stateto==1 & Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==5 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==5 & stateto==3& Year !=2013)),
                      nrow(filter(data0612_Order2, order2comb==6 & stateto==1& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==6 & stateto==2& Year !=2013)),
                      nrow(filter(data0612_Order2,order2comb==6 & stateto==3& Year !=2013))
 ),nrow = 6,ncol=3, byrow = TRUE)

colnames(Order2Transit) <- c("State 1", "State 2", "Churn")
rownames(Order2Transit) <- c("(0,1)", "(1,1)","(2,1)", "(0,2)","(1,2)", "(2,2)")
Order2Transit #Second-order transition counts 

Order2Transit_Prob<-round(Order2Transit/rowSums(Order2Transit)*100,2)
colnames(Order2Transit_Prob) <- c("State 1", "State 2", "Churn")
rownames(Order2Transit_Prob) <- c("(0,1)", "(1,1)","(2,1)", "(0,2)","(1,2)", "(2,2)")
Order2Transit_Prob#Second-order empirical transition probabilities %
```

# Table 3: second-order MLR model

```{r Table3}
# training set
training<-filter(data0612_Order2,Year<2012 & order2comb!=1 & order2comb!=4 & order2comb!=0) # remove new customers

# fit the 2-order MLR model in the paper
fit_2orderMLR <- multinom(stateto ~-1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+   #(1,1)
              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = training)
# The results listed in Table 3
summary(fit_2orderMLR)$coefficients #coefficients
summary(fit_2orderMLR)$standard.errors # standard errors
z_2orderMLR <-summary(fit_2orderMLR)$coefficients/summary(fit_2orderMLR)$standard.errors #Z value
p_2orderMLR <-(1 - pnorm(abs(z_2orderMLR), 0, 1)) * 2# p value
```


```{r order1MLR}
# fit the first order MLR model in the paper
data0612_Order2<-mutate(data0612_Order2,firstorder1=0,firstorder2=0)
data0612_Order2$firstorder1 <- ifelse(data0612_Order2$statefrom=="1",1,0)
data0612_Order2$firstorder2 <- ifelse(data0612_Order2$statefrom=="2",1,0) 
training_1order<-filter(data0612_Order2,Year<2012& order2comb!=1 & order2comb!=4 & order2comb!=0) # also remove new customers

#first order MLR
fit_1orderMLR <- multinom(stateto ~-1+
                  firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + 
                  firstorder2+firstorder2:(EntitySTV+TypeCity +RatioPremium+FreqBC+FinaCris)
                  ,data = training_1order)

summary(fit_1orderMLR)$coefficients #coefficients
summary(fit_1orderMLR)$standard.errors #standard.errors
z_1orderMLR <-summary(fit_1orderMLR)$coefficients/summary(fit_1orderMLR)$standard.errors # z value
p_1orderMLR <-(1 - pnorm(abs(z_1orderMLR), 0, 1)) * 2 # p value
```

# Figure 3: conditional effect v.s. marginal effect

```{r Figure3}
#Figure 3 of the paper: conditional effect and marginal effect
train_state1_ggeffect<- training
ggpredict_fit1 <- fit_2orderMLR

# generate 50 RatioPremium data from min to max
RP50<-seq(-45,430,10)/50
AME_RP<-expand.grid(RP50) #a data frame for average marginal effect plot
colnames(AME_RP) <- c("RatioPremium")
AME_RP<-mutate(AME_RP,prob1=0,prob2=0,prob3=0)

#calculate AME for each combination
for (i in 1:nrow(AME_RP)) {
simulated_frame<-train_state1_ggeffect
simulated_frame$RatioPremium=AME_RP[i,1]
simu_prbos<-predict(ggpredict_fit1, newdata =  simulated_frame, "probs") #using all policyholders, though RatioPremium is not used in some transition
AME_RP[i,c(2:4)]<-colMeans(simu_prbos)
}
# average marginal effect plot
AME_RatioPremium<-ggplot(data=AME_RP,aes(x=RatioPremium)) +  ylab("")+ xlab("RatioPremium")+
  geom_smooth(aes(y=prob1,color="Full-coverage"),se=F,size=1,position = "identity") +
  geom_smooth(aes(y=prob2,color="Partial-coverage"),se=F,size=1,position = "identity")  +
  geom_smooth(aes(y=prob3,color="Churn"),se=F,size=1,position = "identity")   +
  scale_colour_manual(name="State of destination", values=c("Full-coverage"="black", "Partial-coverage"="blue","Churn"="red"),
                      labels=c("Full-coverage", "Partial-coverage","Churn"))+
  coord_cartesian(ylim = c(0, 1))+ facet_grid(. ~ "Average marginal effect") +
        theme(strip.background = element_rect(fill="#E0E0E0"),
              strip.text = element_text(size=8, colour="black"))+theme(legend.position = "none")

Con_PBC_con<-expand.grid(RP50) #construct conditional effect plots
colnames(Con_PBC_con) <- c("RatioPremium")
Con_PBC_con<-mutate(Con_PBC_con,IClaimBC = 0,IClaimIM=0,IClaimCar=0,EntityCM=1,EntityCSTV =1,TypeMisc=0,EntitySTV=0,orderstate_2=0,orderstate_3 =0,orderstate_5 =0,orderstate_6 =1,
RateBC= mean(filter(training,orderstate_6==1)$RateBC),
RateIM=mean(filter(training,orderstate_6==1)$RateIM), 
RateCar=mean(filter(training,orderstate_6==1)$RateCar),
TotalCoverage=mean(filter(training,orderstate_6==1)$TotalCoverage),
FreqBC=0, FinaCris=0) # The "condition".

Con_PBC_con<-mutate(Con_PBC_con,prob1=0,prob2=0,prob3=0)

#calculate conditional effect for each combination
for (i in 1:nrow(Con_PBC_con)) {
simulated_frame=Con_PBC_con[i,]
simu_prbos<-predict(ggpredict_fit1, newdata =  simulated_frame, "probs")
Con_PBC_con[i,c(19:21)]<-simu_prbos
}
#Conditional effect plot
Con_RatioPremium<-ggplot(data=Con_PBC_con,aes(x=RatioPremium)) +  ylab("Transition probabilities")+ xlab("RatioPremium")+
  geom_smooth(aes(y=prob1,color="Full-coverage"),se=F,size=1,position = "identity") +
  geom_smooth(aes(y=prob2,color="Partial-coverage"),se=F,size=1,position = "identity")  +
  geom_smooth(aes(y=prob3,color="Churn"),se=F,size=1,position = "identity")   +
  scale_colour_manual(name="State of destination:", values=c("Full-coverage"="black", "Partial-coverage"="blue","Churn"="red"),
                      labels=c("Full-coverage", "Partial-coverage","Churn"))+
  coord_cartesian(ylim = c(0, 1))+ facet_grid(. ~ "Conditional effect") +
        theme(strip.background = element_rect(fill="#E0E0E0"),
              strip.text = element_text(size=8, colour="black"))+theme(legend.position = "top")

# Figure 3
Con_Ame <- ggarrange(Con_RatioPremium,AME_RatioPremium,
                     vjust = 1.1,
                     hjust=-1.05,
                    font.label = list(size = 10),
                    labels = c(""),
                    ncol = 2, nrow = 1,
                    widths=c(1,1),
                    heights = c(1,1),
                     common.legend = TRUE)
#ggsave("plot.pdf")
```

# Customer Lifetime Value (CLV) analyais (Section 4.4 of the paper)

```{r CLV}
# CLV settings:state-specific revenue, state-specific expense, and interest rate.

#interest rate%
interest<-(4.97+5.02+1.92+0.16+0.18+0.10+0.14)/7

#state-specific average revenue
# if the state is 1
Et1<- mean(filter(training,statefrom==1)$PolicyPremium)*1000 #(dollar value)
# if the state is 2
Et2<- mean(filter(training,statefrom==2)$PolicyPremium)*1000

#state-specific average expense: (claim cost -deductible)
# if the state is 1
At1<- mean(pmax(filter(training,statefrom==1)$ClaimBC-filter(training,statefrom==1)$DeductBC,0) + pmax(filter(training,statefrom==1)$ClaimIM-filter(training,statefrom==1)$DeductIM,0)+pmax(filter(training,statefrom==1)$ClaimPN-filter(training,statefrom==1)$DeductPN,0)+pmax(filter(training,statefrom==1)$ClaimPO-filter(training,statefrom==1)$DeductPO,0)+pmax(filter(training,statefrom==1)$ClaimCN-filter(training,statefrom==1)$DeductCN,0)+pmax(filter(training,statefrom==1)$ClaimCO-filter(training,statefrom==1)$DeductCO,0))
# if the state is 2
At2<- mean(pmax(filter(training,statefrom==2)$ClaimBC-filter(training,statefrom==2)$DeductBC,0) + pmax(filter(training,statefrom==2)$ClaimIM-filter(training,statefrom==2)$DeductIM,0)+pmax(filter(training,statefrom==2)$ClaimPN-filter(training,statefrom==2)$DeductPN,0)+pmax(filter(training,statefrom==2)$ClaimPO-filter(training,statefrom==2)$DeductPO,0)+pmax(filter(training,statefrom==2)$ClaimCN-filter(training,statefrom==2)$DeductCN,0)+pmax(filter(training,statefrom==2)$ClaimCO-filter(training,statefrom==2)$DeductCO,0))

```

```{r BLR12orders}
# Because we need a second-order BLR model to represent the traditional customer churn analysis, so we fit it here. 

#second order BLR: to state 1
blr_model_s2order1<-glm(tostate_1 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = training, family = binomial(link = "logit"))

#second order BLR: to state 2
blr_model_s2order2<-glm(tostate_2 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = training, family = binomial(link = "logit"))

#second order BLR: to state 3
blr_model_s2order3<-glm(tostate_3 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = training, family = binomial(link = "logit"))

```

```{r AveragePolicyholder}
#Now we need specify the covariates for the "average" policyholder
# when the policyholder is in state 1
case_train1<-filter(training,statefrom==1) %>% dplyr::select(orderstate_2,orderstate_3,orderstate_5,orderstate_6,EntitySTV,EntityCM,TypeMisc,TypeCity,EntityCSTV,IClaimBC, IClaimIM, IClaimCar,FinaCris, RateBC, RateIM, RateCar, RatioPremium ,TotalCoverage,FreqBC)
# when the policyholder is in state 2
case_train2<-filter(training,statefrom==2) %>% dplyr::select(orderstate_2,orderstate_3,orderstate_5,orderstate_6,EntitySTV,EntityCM,TypeMisc,TypeCity,EntityCSTV,IClaimBC, IClaimIM, IClaimCar,FinaCris, RateBC, RateIM, RateCar, RatioPremium ,TotalCoverage,FreqBC)

means1<-colMeans(case_train1[,c(15:20)]) #means of numerical covairates (state 1)
means2<-colMeans(case_train2[,c(15:20)]) #means of numerical covairates (state 2)

#values of covariates in first year: state of origin is (1,1)
case_train1_mean<-data.frame(orderstate_2=1,orderstate_3=0,orderstate_5=0,orderstate_6=0,EntitySTV=1,EntityCM=0,EntityCSTV=1,TypeMisc=0,TypeCity=0, IClaimBC=0, IClaimIM=0,IClaimCar=0,FinaCris=0,RateBC=means1[1], RateIM=means1[2], RateCar=means1[3], RatioPremium=means1[4],TotalCoverage=means1[5],FreqBC=means1[6])

#values of covariates in second year: state of origin can be (1,1), as the first case
case_train11_mean<-data.frame(orderstate_2=1,orderstate_3=0,orderstate_5=0,orderstate_6=0,EntitySTV=1,EntityCM=0,EntityCSTV=1,TypeMisc=0,TypeCity=0, IClaimBC=0, IClaimIM=0,IClaimCar=0,FinaCris=0,RateBC=means1[1], RateIM=means1[2], RateCar=means1[3], RatioPremium=means1[4],TotalCoverage=means1[5],FreqBC=means1[6])
#values of covariates in second year: state of origin can be (1,2), as the second case
case_train12_mean<-data.frame(orderstate_2=0,orderstate_3=0,orderstate_5=1,orderstate_6=0,EntitySTV=1,EntityCM=0,EntityCSTV=1,TypeMisc=0,TypeCity=0, IClaimBC=0, IClaimIM=0,IClaimCar=0,FinaCris=0,RateBC=means2[1], RateIM=means2[2], RateCar=means2[3], RatioPremium=means2[4],TotalCoverage=means2[5],FreqBC=means2[6])

# Predictions of the 2-order BLR for traditional customer churn analysis
blr2order_prob1<-predict(blr_model_s2order3,newdata=case_train1_mean,"response")
blr2order_prob2<-predict(blr_model_s2order3,newdata=case_train11_mean,"response")

# three scenarios and corresponding probabilities of the traditional customer churn analysis
blr2order_twoyear<-data.frame(stay=(1-blr2order_prob1)*(1-blr2order_prob2),  churn_after= (1-blr2order_prob1)*blr2order_prob2,churn_now=blr2order_prob1) 

blr2order_CLV<-data.frame(stay=blr2order_twoyear[1]*((Et1-At1)/(1+interest)+(Et1-At1)/(1+interest)^2),
                    churn_after= blr2order_twoyear[2]*(Et1-At1)/(1+interest),churn_now=0)

#CLV of traditional customer churn: 2-order BLR; see Table 5
Traditional_CLV<-matrix(c(as.numeric(blr2order_twoyear),as.numeric(blr2order_CLV)),nrow=3,ncol=2,byrow=F)
Traditional_CLV<-rbind(Traditional_CLV,colSums(Traditional_CLV))
colnames(Traditional_CLV)<-c("Probability","EPV")
rownames(Traditional_CLV) <- c("(full,full)", "(full,churn)","(churn)","Sum")
Traditional_CLV #Table 5: traditional customer churn analysis


#2-order MLR for multi-state customer analysis
MLRnowyear<-predict(fit_2orderMLR,newdata=case_train1_mean,"probs") #this year from (1,1): predicting next state

MLRnextyear1<-predict(fit_2orderMLR,newdata=case_train11_mean,"probs") #next year from (1,1): predicting next state
MLRnextyear2<-predict(fit_2orderMLR,newdata=case_train12_mean,"probs") #next year from (1,2): predicting next state

#predicted probabilities of seven scenarios
ProbMLR7<-c(MLRnowyear[1]*MLRnextyear1[1], #1,1
            MLRnowyear[1]*MLRnextyear1[2], #1,2
            MLRnowyear[1]*MLRnextyear1[3], #1,3
            MLRnowyear[2]*MLRnextyear2[1], #2,1
            MLRnowyear[2]*MLRnextyear2[2], #2,2
            MLRnowyear[2]*MLRnextyear2[3], #2,3
            MLRnowyear[3]                  #3,0
            )
MLR_CLV<-data.frame(s11=ProbMLR7[1]*((Et1-At1)/(1+interest)+(Et1-At1)/(1+interest)^2),
                    s12=ProbMLR7[2]*((Et1-At1)/(1+interest)+(Et2-At2)/(1+interest)^2),
                    s13=ProbMLR7[3]*((Et1-At1)/(1+interest)),
                    s21=ProbMLR7[4]*((Et2-At2)/(1+interest)+(Et1-At1)/(1+interest)^2),
                    s22=ProbMLR7[5]*((Et2-At2)/(1+interest)+(Et2-At2)/(1+interest)^2),
                    s23=ProbMLR7[6]*((Et2-At2)/(1+interest)),
                    s30=0)              
#CLV of multi-state customer churn: 2-order MLR; see Table 5 
Multistate_CLV<-matrix(c(as.numeric(ProbMLR7),as.numeric(MLR_CLV)),nrow=7,ncol=2,byrow=F)
Multistate_CLV<-rbind(Multistate_CLV,colSums(Multistate_CLV))
colnames(Multistate_CLV)<-c("Probability","EPV")
rownames(Multistate_CLV) <- c("(full,full)", "(full,partial)","(full,churn)","(partial,full)", "(partial,partial)","(partial,churn)","churn","Sum")
Multistate_CLV# Table 5:multi-state customer churn analysis
```

# Assessing out-of-sample performance (Section 5 of the paper)

```{r BLR1order}
# Note the 2-order MLR model has been built in the CLV section, so we only fit a first-order BLR in this section.
# 1-order BLR: to state 1
blr_model_s1<-glm(tostate_1 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = training_1order, family = binomial(link = "logit"))
# 1-order BLR: to state 2
blr_model_s2<-glm(tostate_2 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = training_1order, family = binomial(link = "logit"))
# 1-order BLR: to state 3
blr_model_s3<-glm(tostate_3 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = training_1order, family = binomial(link = "logit"))
```

```{r GBM}
library(caret)
library(gbm)
set.seed(2022)# Note, a different seed may lead to a different result for GBM tuning, and also a different balanced training set.

#traincontrol of log loss for multinomial GBM
trainControl_try <- trainControl(method="repeatedcv", number=5,repeats=1,allowParallel=TRUE, classProbs = TRUE,summaryFunction = mnLogLoss)
# tune grid of four hyperparameters
caretGrid_try <-expand.grid(interaction.depth=c(1,2), n.trees = (1:25)*200,
                   shrinkage=c(0.01),
                   n.minobsinnode=c(10))
training<-mutate(training,AvPremiumBC=RateBC,AvPremiumIM=RateIM,AvPremiumCar=RateCar) #we do this because we changed the variables names once. AvePremium was the initial name of Rate. And we use AvPremium to tune ML models.
train_rename<-training
train_rename<-mutate(train_rename,stateto_newname=0)
train_rename$stateto_newname<-as.factor(ifelse(training$stateto=="1","to1",ifelse(training$stateto=="2","to2","to3")))

#balance data: state of destination is balanced
#balance_train: the balanced training set
balance_train <- upSample(x = train_rename[,-which(colnames(train_rename) == "stateto_newname")],y = train_rename$stateto_newname)
balance_train<-mutate(balance_train,firstorder1=0,firstorder2=0)
balance_train$firstorder1 <- ifelse(balance_train$statefrom=="1",1,0)
balance_train$firstorder2 <- ifelse(balance_train$statefrom=="2",1,0) 

#Note: to speed up train(.), we can use parallel computing:
#library(parallel)
#library(doParallel)
#no_cores <- parallel::detectCores() - 1 # number of cores of your computer
#Leave one core available for Operating system
#cluster <- makePSOCKcluster(no_cores)
#registerDoParallel(cluster) #start parallel computing

#tuning process....

# when finish training, stop the parallel computing:
#stopCluster(cluster)

# The code of tuning:
gbm_caret <- train(stateto_newname ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + AvPremiumBC+ AvPremiumIM+ AvPremiumCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, 
    data = train_rename,
    distribution="multinomial",
   method="gbm", 
    trControl=trainControl_try,
    tuneGrid=caretGrid_try,
    metric="logLoss",
    preProcess = c("center", "scale"))  

# train a GBM in the balanced data set
gbm_caret_bal <- train(Class ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + AvPremiumBC+ AvPremiumIM+ AvPremiumCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, 
    data = balance_train,
    distribution="multinomial",
    method="gbm", 
    trControl=trainControl_try,
    tuneGrid=caretGrid_try,
    metric="logLoss",
    preProcess = c("center", "scale")) 

#Note: training GBMs is time consuming, so we saved the tuned models here for later use:
#save(gbm_caret,file="gbm_caret_ori2022.RData") #GBM in the original data
#save(gbm_caret_bal,file="gbm_caret_bal2022.RData")#GBM in the balanced data

```


```{r MLRsBalanced}
# Fit 2-order and 1-order MLR models using balanced training set
#2nd order MLR balanced training
fit_2orderMLR_bal <- multinom(Class ~-1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = balance_train)

#1nd order MLR balanced training
fit_1orderMLR_bal <- multinom(Class ~-1+
                  firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + 
                  firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris)
                  ,data = balance_train)
```

```{r}
# Fit 2-order and 1-order BLR models using balanced training set
#first order BLR balanced: to state 1
blr_model_s1_bal<-glm(tostate_1 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = balance_train, family = binomial(link = "logit"))
#first order BLR balanced: to state 2
blr_model_s2_bal<-glm(tostate_2 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = balance_train, family = binomial(link = "logit"))
#first order BLR balanced: to state 3
blr_model_s3_bal<-glm(tostate_3 ~ -1+ firstorder1+firstorder1:(EntitySTV+EntityCM + RateBC+ RateIM+ RateCar+IClaimBC+ IClaimIM+IClaimCar + RatioPremium +TotalCoverage) + firstorder2+firstorder2:(EntitySTV +TypeCity +RatioPremium+FreqBC+FinaCris), data = balance_train, family = binomial(link = "logit"))


#second order BLR balanced: to state 1
blr_model_s2order1_bal<-glm(tostate_1 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = balance_train, family = binomial(link = "logit"))

#second order BLR balanced: to state 2
blr_model_s2order2_bal<-glm(tostate_2 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = balance_train, family = binomial(link = "logit"))

#second order BLR balanced: to state 3
blr_model_s2order3_bal<-glm(tostate_3 ~ -1+
            orderstate_2+ (EntitySTV+EntityCM+RateBC+RateIM+RateCar+IClaimBC+IClaimIM+TotalCoverage+RatioPremium):orderstate_2+              orderstate_3+ (IClaimCar+EntitySTV):orderstate_3   +           #(2,1)
              orderstate_5+ (EntitySTV+RateIM):orderstate_5+                     #(1,2)
               orderstate_6+ (EntityCSTV+RatioPremium+FreqBC+FinaCris):orderstate_6     #(2,2)
                ,data = balance_train, family = binomial(link = "logit"))
```

```{r SVM12}
#Fit a SVM model
library(e1071)
set.seed(2022)
train_controlsvm <- trainControl(method="repeatedcv", number=10, repeats=1)

#Note: to speed up train(.), we can use parallel computing:
#library(parallel)
#library(doParallel)
#no_cores <- parallel::detectCores() - 1 # number of cores of your computer
#Leave one core available for Operating system
#cluster <- makePSOCKcluster(no_cores)
#registerDoParallel(cluster) #start parallel computing

#tuning process....

# when finish training, stop the parallel computing:
#stopCluster(cluster)
# Tuning SVM in the original training set
svm<- train(stateto ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + AvPremiumBC+ AvPremiumIM+ AvPremiumCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, data = training, method = "svmRadial", trControl = train_controlsvm, preProcess = c("center","scale"), tuneLength = 15)
# construct the SVM using tuned HPs
svm1<-svm(stateto ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + AvPremiumBC+ AvPremiumIM+ AvPremiumCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, data = training, method = "radial", probability=TRUE, gamma = 0.03261639, cost = 4)
#save(svm1,file="svm_caret_ori2022.RData") #svm in the original data

# Tuning SVM in the balanced training set
svm_bal<- train(Class ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + RateBC+ RateIM+ RateCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, data = balance_train, method = "svmRadial", trControl = train_controlsvm, preProcess = c("center","scale"), tuneLength = 15)
# construct the SVM using tuned HPs
svm1_bal<-svm(Class ~ Length+ IClaimBC+ IClaimIM+ IClaimCar+ TypeSchool+TypeCity+TypeVillage+TypeMisc+TypeTown+TypeCity + RateBC+ RateIM+ RateCar + RatioPremium +logCoverageBC+logCoverageIM+logCoverageCar +InflationR+FreqBC+FreqIM+FreqCar+SeverityBC+SeverityIM+SeverityCar+PolicyPremium +PolicyClaim+FinaCris+orderstate_2+orderstate_3+orderstate_5+orderstate_6, data = balance_train, method = "radial", probability=TRUE, gamma = 0.0337012, cost = 4096)
#save(svm1_bal,file="svm_caret_bal2022.RData") #svm in the balanced data

#Note: training SVMs is time consuming, so we saved the tuned models here for later use.
```

## AUCs (Section 5.1 of the paper)

```{r AUCs}
# construct the test set
testset<-filter(data0612_Order2,Year>2011 & Year!=2013 & order2comb!=1 & order2comb!=4 & order2comb!=0)
testset<-mutate(testset,AvPremiumBC=RateBC,AvPremiumIM=RateIM,AvPremiumCar=RateCar)
# Get the predictions of all models in the test set
#2-order MLR  (original)
Pre_2orderMLR <- predict(fit_2orderMLR, newdata = testset, "probs")
#2-order MLR  (balanced)
Pre_2orderMLR_bal <- predict(fit_2orderMLR_bal, newdata = testset, "probs")

#1-order MLR (original)
Pre_1orderMLR <- predict(fit_1orderMLR, newdata = testset, "probs")
#2-order MLR (balanced)
Pre_1orderMLR_bal <- predict(fit_1orderMLR_bal, newdata = testset, "probs")


# first order one-vs-all BLR (original)
PreBLR1 <- predict(blr_model_s1, newdata = testset, "response")
PreBLR2 <- predict(blr_model_s2, newdata = testset, "response")
PreBLR3 <- predict(blr_model_s3, newdata = testset, "response")

# second order one-vs-all BLR (original)
PreBLR2order1 <- predict(blr_model_s2order1, newdata = testset, "response")
PreBLR2order2 <- predict(blr_model_s2order2, newdata = testset, "response")
PreBLR2order3 <- predict(blr_model_s2order3, newdata = testset, "response")

# first order one-vs-all BLR (balanced)
PreBLR1_bal <- predict(blr_model_s1_bal, newdata = testset, "response")
PreBLR2_bal <- predict(blr_model_s2_bal, newdata = testset, "response")
PreBLR3_bal <- predict(blr_model_s3_bal, newdata = testset, "response")

# second order one-vs-all BLR (balanced)
PreBLR2order1_bal <- predict(blr_model_s2order1_bal, newdata = testset, "response")
PreBLR2order2_bal <- predict(blr_model_s2order2_bal, newdata = testset, "response")
PreBLR2order3_bal <- predict(blr_model_s2order3_bal, newdata = testset, "response")

# GBM original training
load("gbm_caret_ori2022.RData")
Pre_GBM_ori<-predict(gbm_caret, newdata = testset, type="prob")

# GBM balanced training
load("gbm_caret_bal2022.RData")
Pre_GBM_bal<-predict(gbm_caret_bal, newdata = testset, type="prob")


# SVM original training
load("svm_caret_ori2022.RData")
predSVM1 <- predict(svm1, newdata = testset, probability=TRUE) # class
probsSVM1<-attr(predSVM1,"probabilities") #SVM predicition of probabilities

# SVM balanced training
load("svm_caret_bal2022.RData")
predSVM1_bal <- predict(svm1_bal, newdata = testset, probability=TRUE) # class
probsSVM1_bal<-attr(predSVM1_bal,"probabilities") #SVM predicition of probabilities

#AUCs
AUC_multi_test1<-data.frame(T11_true=testset$tostate_1, T12_true=testset$tostate_2,T13_true=testset$tostate_3,
               T11_pred_MLRo2=Pre_2orderMLR[,1], T12_pred_MLRo2=Pre_2orderMLR[,2], T13_pred_MLRo2=Pre_2orderMLR[,3], #MLR-order2
               T11_pred_MLRo1=Pre_1orderMLR[,1], T12_pred_MLRo1=Pre_1orderMLR[,2], T13_pred_MLRo1=Pre_1orderMLR[,3], #MLR-order1
               T11_pred_SVM_ori=probsSVM1[,1], T12_pred_SVM_ori=probsSVM1[,2], T13_pred_SVM_ori=probsSVM1[,3],
               T11_pred_GBM_ori=Pre_GBM_ori[,1,], T12_pred_GBM_ori=Pre_GBM_ori[,2,], T13_pred_GBM_ori=Pre_GBM_ori[,3,],
               T11_pred_BLR=PreBLR1, T12_pred_BLR=PreBLR2, T13_pred_BLR=PreBLR3,
               T11_pred_BLRo2=PreBLR2order1, T12_pred_BLRo2=PreBLR2order2, T13_pred_BLRo2=PreBLR2order3,
               T11_pred_MLRo2_bal=Pre_2orderMLR_bal[,1], T12_pred_MLRo2_bal=Pre_2orderMLR_bal[,2], T13_pred_MLRo2_bal=Pre_2orderMLR_bal[,3],
               T11_pred_MLRo1_bal=Pre_1orderMLR_bal[,1], T12_pred_MLRo1_bal=Pre_1orderMLR_bal[,2], T13_pred_MLRo1_bal=Pre_1orderMLR_bal[,3],
               T11_pred_SVM_bal=probsSVM1_bal[,1], T12_pred_SVM_bal=probsSVM1_bal[,2], T13_pred_SVM_bal=probsSVM1_bal[,3],
               T11_pred_BLR_bal=PreBLR1_bal, T12_pred_BLR_bal=PreBLR2_bal, T13_pred_BLR_bal=PreBLR3_bal,
               T11_pred_BLRo2_bal=PreBLR2order1_bal, T12_pred_BLRo2_bal=PreBLR2order2_bal, T13_pred_BLRo2_bal=PreBLR2order3_bal,
               T11_pred_GBM_bal=Pre_GBM_bal[,1,], T12_pred_GBM_bal=Pre_GBM_bal[,2,], T13_pred_GBM_bal=Pre_GBM_bal[,3,]) 

AUC_multi_results_test<-multi_roc(AUC_multi_test1, force_diag=TRUE)

#Table 6 of the paper
#Build a Table to input AUCs
AUC_Table<-matrix(0,nrow = 12,ncol=5,byrow = T)
#2-order MLR (origin)
AUC_Table[1,1]<-AUC_multi_results_test$AUC$MLRo2$T11
AUC_Table[1,2]<-AUC_multi_results_test$AUC$MLRo2$T12
AUC_Table[1,3]<-AUC_multi_results_test$AUC$MLRo2$T13
AUC_Table[1,4]<-AUC_multi_results_test$AUC$MLRo2$macro
AUC_Table[1,5]<-AUC_multi_results_test$AUC$MLRo2$micro
#1-order MLR (origin)
AUC_Table[2,1]<-AUC_multi_results_test$AUC$MLRo1$T11
AUC_Table[2,2]<-AUC_multi_results_test$AUC$MLRo1$T12
AUC_Table[2,3]<-AUC_multi_results_test$AUC$MLRo1$T13
AUC_Table[2,4]<-AUC_multi_results_test$AUC$MLRo1$macro
AUC_Table[2,5]<-AUC_multi_results_test$AUC$MLRo1$micro
#2-order BLR (origin)
AUC_Table[3,1]<-AUC_multi_results_test$AUC$BLRo2$T11
AUC_Table[3,2]<-AUC_multi_results_test$AUC$BLRo2$T12
AUC_Table[3,3]<-AUC_multi_results_test$AUC$BLRo2$T13
AUC_Table[3,4]<-AUC_multi_results_test$AUC$BLRo2$macro
AUC_Table[3,5]<-AUC_multi_results_test$AUC$BLRo2$micro
#1-order BLR (origin)
AUC_Table[4,1]<-AUC_multi_results_test$AUC$BLR$T11
AUC_Table[4,2]<-AUC_multi_results_test$AUC$BLR$T12
AUC_Table[4,3]<-AUC_multi_results_test$AUC$BLR$T13
AUC_Table[4,4]<-AUC_multi_results_test$AUC$BLR$macro
AUC_Table[4,5]<-AUC_multi_results_test$AUC$BLR$micro
#SVM (origin)
AUC_Table[5,1]<-AUC_multi_results_test$AUC$SVM_ori$T11
AUC_Table[5,2]<-AUC_multi_results_test$AUC$SVM_ori$T12
AUC_Table[5,3]<-AUC_multi_results_test$AUC$SVM_ori$T13
AUC_Table[5,4]<-AUC_multi_results_test$AUC$SVM_ori$macro
AUC_Table[5,5]<-AUC_multi_results_test$AUC$SVM_ori$micro
#GBM (origin)
AUC_Table[6,1]<-AUC_multi_results_test$AUC$GBM_ori$T11
AUC_Table[6,2]<-AUC_multi_results_test$AUC$GBM_ori$T12
AUC_Table[6,3]<-AUC_multi_results_test$AUC$GBM_ori$T13
AUC_Table[6,4]<-AUC_multi_results_test$AUC$GBM_ori$macro
AUC_Table[6,5]<-AUC_multi_results_test$AUC$GBM_ori$micro

#2-order MLR (balance)
AUC_Table[7,1]<-AUC_multi_results_test$AUC$MLRo2_bal$T11
AUC_Table[7,2]<-AUC_multi_results_test$AUC$MLRo2_bal$T12
AUC_Table[7,3]<-AUC_multi_results_test$AUC$MLRo2_bal$T13
AUC_Table[7,4]<-AUC_multi_results_test$AUC$MLRo2_bal$macro
AUC_Table[7,5]<-AUC_multi_results_test$AUC$MLRo2_bal$micro
#1-order MLR (balance)
AUC_Table[8,1]<-AUC_multi_results_test$AUC$MLRo1_bal$T11
AUC_Table[8,2]<-AUC_multi_results_test$AUC$MLRo1_bal$T12
AUC_Table[8,3]<-AUC_multi_results_test$AUC$MLRo1_bal$T13
AUC_Table[8,4]<-AUC_multi_results_test$AUC$MLRo1_bal$macro
AUC_Table[8,5]<-AUC_multi_results_test$AUC$MLRo1_bal$micro
#2-order BLR (balance)
AUC_Table[9,1]<-AUC_multi_results_test$AUC$BLRo2_bal$T11
AUC_Table[9,2]<-AUC_multi_results_test$AUC$BLRo2_bal$T12
AUC_Table[9,3]<-AUC_multi_results_test$AUC$BLRo2_bal$T13
AUC_Table[9,4]<-AUC_multi_results_test$AUC$BLRo2_bal$macro
AUC_Table[9,5]<-AUC_multi_results_test$AUC$BLRo2_bal$micro
#1-order BLR (balance)
AUC_Table[10,1]<-AUC_multi_results_test$AUC$BLR_bal$T11
AUC_Table[10,2]<-AUC_multi_results_test$AUC$BLR_bal$T12
AUC_Table[10,3]<-AUC_multi_results_test$AUC$BLR_bal$T13
AUC_Table[10,4]<-AUC_multi_results_test$AUC$BLR_bal$macro
AUC_Table[10,5]<-AUC_multi_results_test$AUC$BLR_bal$micro
#SVM (balance)
AUC_Table[11,1]<-AUC_multi_results_test$AUC$SVM_bal$T11
AUC_Table[11,2]<-AUC_multi_results_test$AUC$SVM_bal$T12
AUC_Table[11,3]<-AUC_multi_results_test$AUC$SVM_bal$T13
AUC_Table[11,4]<-AUC_multi_results_test$AUC$SVM_bal$macro
AUC_Table[11,5]<-AUC_multi_results_test$AUC$SVM_bal$micro
#GBM (balance)
AUC_Table[12,1]<-AUC_multi_results_test$AUC$GBM_bal$T11
AUC_Table[12,2]<-AUC_multi_results_test$AUC$GBM_bal$T12
AUC_Table[12,3]<-AUC_multi_results_test$AUC$GBM_bal$T13
AUC_Table[12,4]<-AUC_multi_results_test$AUC$GBM_bal$macro
AUC_Table[12,5]<-AUC_multi_results_test$AUC$GBM_bal$micro
colnames(AUC_Table) <- c("AUC(full)", "AUC(partial)", "AUC(churn)","Macro-AUC","Micro-AUC")
rownames(AUC_Table) <- c("Ori: 2-order MLR","Ori: 1-order MLR","Ori: 2-order BLR","Ori: 1-order BLR","Ori: SVM","Ori: GBM",
                             "Bal: 2-order MLR","Bal: 1-order MLR","Bal: 2-order BLR","Bal: 1-order BLR","Bal: SVM","Bal: GBM")
AUC_Table
```


## Top-decile lifts (Section 5.2 of the paper)

```{r topdecilelifts}
#Table 7 of the paper
# Define a function to calculate top-decile lifts for each state of destination
#input three predicted transition probabilities in the test set

TDLs<-function(predto1,predto2,predto3){
 #top 10 segment for 3 transitions (MLR)
num1toots_top<-ceiling(nrow(testset)*0.1) #1039 obs in test, so we need 104 obs for top decile 
#create data frame to record top 10 % segment
topfrom1toots<-data.frame(topstateto1=c(1:num1toots_top), topstateto2=0,topstateto3=0,pi1=0,pi2=0,pi3=0)

#index
#the policyholders with the top 10% probs to state 1
topfrom1toots$topstateto1 <- order(predto1,decreasing = TRUE)[1:num1toots_top]
#the policyholders with the top 10% probs to state 2
topfrom1toots$topstateto2 <- order(predto2,decreasing = TRUE)[1:num1toots_top]
#the policyholders with the top 10% probs to state 3
topfrom1toots$topstateto3 <- order(predto3,decreasing = TRUE)[1:num1toots_top]

#pi for three states in the whole test
pitest<-matrix(rep(0,3),nrow=1)
  pitest[1,1]<-nrow(filter(testset,stateto==1))/nrow(testset)
  pitest[1,2]<-nrow(filter(testset,stateto==2))/nrow(testset)
  pitest[1,3]<-nrow(filter(testset,stateto==3))/nrow(testset)
  
#pi for in top 10 segment
pitop10<-matrix(rep(0,3),nrow=1)
#proportion of transitions in top 10 risky segment
for (i in c(1:num1toots_top) ){
  topfrom1toots[i,4]<- ifelse(testset[topfrom1toots[i,1],"stateto"]==1,1,0) #whether the predicted to state 1 is truly to state 1 in test set
  topfrom1toots[i,5]<- ifelse(testset[topfrom1toots[i,2],"stateto"]==2,1,0)
  topfrom1toots[i,6]<- ifelse(testset[topfrom1toots[i,3],"stateto"]==3,1,0)
}

pitop10[1,1]<-sum(topfrom1toots[,4])/num1toots_top
pitop10[1,2]<-sum(topfrom1toots[,5])/num1toots_top
pitop10[1,3]<-sum(topfrom1toots[,6])/num1toots_top
# top decile lifts
topdecile<-pitop10/pitest

topdecile
}

#Top decile-lifts
TopDecile_table<-rbind(
TDLs(Pre_2orderMLR[,1],Pre_2orderMLR[,2],Pre_2orderMLR[,3]),#2-order MLR (origin)
TDLs(Pre_1orderMLR[,1],Pre_1orderMLR[,2],Pre_1orderMLR[,3]),#1-order MLR (origin)
TDLs(PreBLR2order1,PreBLR2order2,PreBLR2order3),#2-order BLR (origin)
TDLs(PreBLR1,PreBLR2,PreBLR3),#1-order BLR (origin)
TDLs(probsSVM1[,1],probsSVM1[,2],probsSVM1[,3]),#SVM (origin)
TDLs(Pre_GBM_ori[,1],Pre_GBM_ori[,2],Pre_GBM_ori[,3]),#GBM (origin)
TDLs(Pre_2orderMLR_bal[,1],Pre_2orderMLR_bal[,2],Pre_2orderMLR_bal[,3]),#2-order MLR(balance)
TDLs(Pre_1orderMLR_bal[,1],Pre_1orderMLR_bal[,2],Pre_1orderMLR_bal[,3]),#1-order MLR (balance)
TDLs(PreBLR2order1_bal,PreBLR2order2_bal,PreBLR2order3_bal),#2-order BLR (balance)
TDLs(PreBLR1_bal,PreBLR2_bal,PreBLR3_bal),#1-order BLR (balance)
TDLs(probsSVM1_bal[,1],probsSVM1_bal[,2],probsSVM1_bal[,3]),#SVM (balance)
TDLs(Pre_GBM_bal[,1],Pre_GBM_bal[,2],Pre_GBM_bal[,3]) )#GBM (balance)


colnames(TopDecile_table) <- c("State 1", "State 2", "Churn")
rownames(TopDecile_table) <- c("Ori: 2-order MLR","Ori: 1-order MLR","Ori: 2-order BLR","Ori: 1-order BLR","Ori: SVM","Ori: GBM",
                             "Bal: 2-order MLR","Bal: 1-order MLR","Bal: 2-order BLR","Bal: 1-order BLR","Bal: SVM","Bal: GBM")
TopDecile_table

```

